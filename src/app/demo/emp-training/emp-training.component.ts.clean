import { Component, OnInit, TemplateRef, ViewChild } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';
import { NgbModule, NgbModal } from '@ng-bootstrap/ng-bootstrap';
import Swal from 'sweetalert2';

interface Training {
  id?: string;
  trainingName: string;
  trainingCode: string;
  description: string;
  startDate: string;
  endDate: string;
  status: 'Planned' | 'In Progress' | 'Completed' | 'Cancelled';
  trainerName: string;
  location: string;
  maxParticipants: number;
  participants: string[];
}

@Component({
  selector: 'app-emp-training',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    RouterModule,
    NgbModule
  ],
  templateUrl: './emp-training.component.html',
  styleUrls: ['./emp-training.component.scss']
})
export class EmpTrainingComponent implements OnInit {
  // Data
  trainings: Training[] = [];
  filteredTrainings: Training[] = [];
  currentTraining: Training | null = null;
  
  // Search and Filter
  searchQuery = '';
  showFilterPanel = false;
  
  // Filter options
  filterOptions = {
    status: new Set<string>(),
    locations: new Set<string>(),
    selectedStatus: new Set<string>(),
    selectedLocations: new Set<string>(),
    selectedDateRange: [null, null] as [Date | null, Date | null]
  };

  // Date range for filtering
  dateRange: [Date | null, Date | null] = [null, null];
  
  // Pagination
  currentPage = 1;
  itemsPerPage = 10;
  totalPages = 1;
  
  // UI State
  isEditMode = false;
  isLoading = false;
  errorMessage = '';

  // Forms
  form: FormGroup;
  
  // Template Refs
  @ViewChild('trainingModal') private trainingModalRef!: TemplateRef<any>;
  @ViewChild('viewTrainingModal') private viewTrainingModalRef!: TemplateRef<any>;
  private modalRef: any;

  constructor(
    private fb: FormBuilder,
    private modalService: NgbModal
  ) {
    this.form = this.fb.group({
      id: [''],
      trainingName: ['', [Validators.required, Validators.maxLength(100)]],
      trainingCode: ['', [
        Validators.required, 
        Validators.pattern('^[A-Za-z0-9-]+$'),
        Validators.maxLength(20)
      ]],
      description: ['', Validators.maxLength(500)],
      startDate: ['', Validators.required],
      endDate: ['', Validators.required],
      status: ['Planned', Validators.required],
      trainerName: ['', [Validators.required, Validators.maxLength(100)]],
      location: ['', Validators.required],
      maxParticipants: ['', [
        Validators.required, 
        Validators.min(1), 
        Validators.max(100),
        Validators.pattern('^[0-9]*$')
      ]],
      participants: [[]]
    }, { validators: this.dateRangeValidator });
  }

  ngOnInit(): void {
    this.loadTrainings();
  }

  loadTrainings(): void {
    this.isLoading = true;
    // Simulate API call
    setTimeout(() => {
      this.trainings = [
        {
          id: '1',
          trainingName: 'Angular Fundamentals',
          trainingCode: 'ANG-101',
          description: 'Learn Angular basics',
          startDate: '2023-06-01',
          endDate: '2023-06-05',
          status: 'Completed',
          trainerName: 'John Doe',
          location: 'Training Room A',
          maxParticipants: 15,
          participants: ['Alice', 'Bob']
        },
        {
          id: '2',
          trainingName: 'Advanced React',
          trainingCode: 'REA-201',
          description: 'Advanced React patterns and best practices',
          startDate: '2023-07-10',
          endDate: '2023-07-15',
          status: 'In Progress',
          trainerName: 'Jane Smith',
          location: 'Virtual',
          maxParticipants: 20,
          participants: ['Charlie', 'David', 'Eve']
        },
        {
          id: '3',
          trainingName: 'Node.js Backend',
          trainingCode: 'NODE-102',
          description: 'Building scalable backend services with Node.js',
          startDate: '2023-08-01',
          endDate: '2023-08-10',
          status: 'Planned',
          trainerName: 'Mike Johnson',
          location: 'Training Room B',
          maxParticipants: 12,
          participants: []
        }
      ];
      this.filteredTrainings = [...this.trainings];
      this.updateFilterOptions();
      this.isLoading = false;
    }, 500);
  }

  dateRangeValidator(group: AbstractControl): { [key: string]: boolean } | null {
    const startDate = group.get('startDate')?.value;
    const endDate = group.get('endDate')?.value;
    
    if (!startDate || !endDate) return null;
    
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    if (start > end) {
      group.get('endDate')?.setErrors({ dateRangeInvalid: true });
      return { dateRangeInvalid: true };
    }
    
    group.get('endDate')?.setErrors(null);
    return null;
  }

  applyFilters(): void {
    this.filteredTrainings = this.trainings.filter(training => {
      // Search filter
      const searchLower = this.searchQuery.toLowerCase();
      const matchesSearch = !this.searchQuery || 
        training.trainingName.toLowerCase().includes(searchLower) ||
        training.trainingCode.toLowerCase().includes(searchLower) ||
        training.trainerName.toLowerCase().includes(searchLower);
      
      // Status filter
      const matchesStatus = this.filterOptions.selectedStatus.size === 0 || 
        this.filterOptions.selectedStatus.has(training.status);
      
      // Location filter
      const matchesLocation = this.filterOptions.selectedLocations.size === 0 || 
        this.filterOptions.selectedLocations.has(training.location);
      
      // Date range filter
      const [startDate, endDate] = this.dateRange;
      const trainingStartDate = new Date(training.startDate);
      const trainingEndDate = new Date(training.endDate);
      
      let matchesDateRange = true;
      if (startDate) {
        matchesDateRange = matchesDateRange && trainingEndDate >= new Date(startDate);
      }
      if (endDate) {
        matchesDateRange = matchesDateRange && trainingStartDate <= new Date(endDate);
      }
      
      return matchesSearch && matchesStatus && matchesLocation && matchesDateRange;
    });
    
    this.currentPage = 1;
    this.updateTotalPages();
  }

  updateFilterOptions(): void {
    // Update available status and location options based on current data
    const statuses = new Set<string>();
    const locations = new Set<string>();
    
    this.trainings.forEach(training => {
      statuses.add(training.status);
      locations.add(training.location);
    });
    
    this.filterOptions.status = statuses;
    this.filterOptions.locations = locations;
    
    // Update pagination
    this.updateTotalPages();
  }

  openAddModal(): void {
    this.isEditMode = false;
    this.currentTraining = null;
    this.form.reset({
      status: 'Planned',
      maxParticipants: 10
    });
    this.modalRef = this.modalService.open(this.trainingModalRef, { size: 'lg' });
  }

  openEditModal(training: Training): void {
    this.isEditMode = true;
    this.currentTraining = { ...training };
    this.form.patchValue({
      ...training,
      startDate: this.formatDateForInput(training.startDate),
      endDate: this.formatDateForInput(training.endDate)
    });
    this.modalRef = this.modalService.open(this.trainingModalRef, { size: 'lg' });
  }

  openViewModal(training: Training): void {
    this.currentTraining = training;
    this.modalRef = this.modalService.open(this.viewTrainingModalRef, { size: 'lg' });
  }

  saveTraining(): void {
    if (this.form.invalid) {
      this.form.markAllAsTouched();
      return;
    }

    const formData = this.form.value;
    const training: Training = {
      ...formData,
      id: this.currentTraining?.id || Date.now().toString(),
      participants: this.currentTraining?.participants || []
    };

    if (this.isEditMode && this.currentTraining?.id) {
      // Update existing training
      const index = this.trainings.findIndex(t => t.id === this.currentTraining?.id);
      if (index !== -1) {
        this.trainings[index] = training;
        this.showSuccess('Training updated successfully');
      }
    } else {
      // Add new training
      this.trainings.unshift(training);
      this.showSuccess('Training added successfully');
    }

    this.filteredTrainings = [...this.trainings];
    this.updateFilterOptions();
    this.modalRef.close();
  }

  clearFilters(): void {
    this.searchQuery = '';
    this.filterOptions.selectedStatus.clear();
    this.filterOptions.selectedLocations.clear();
    this.dateRange = [null, null];
    this.applyFilters();
  }

  onDateRangeSelect(): void {
    if (this.dateRange[0] && this.dateRange[1]) {
      this.applyFilters();
    }
  }

  getStatusBadgeClass(status: string): string {
    switch (status) {
      case 'Planned': return 'bg-info';
      case 'In Progress': return 'bg-warning text-dark';
      case 'Completed': return 'bg-success';
      case 'Cancelled': return 'bg-danger';
      default: return 'bg-secondary';
    }
  }

  confirmDelete(id: string): void {
    Swal.fire({
      title: 'Are you sure?',
      text: 'You will not be able to recover this training record!',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonText: 'Yes, delete it!',
      cancelButtonText: 'No, keep it'
    }).then((result) => {
      if (result.isConfirmed) {
        this.trainings = this.trainings.filter(t => t.id !== id);
        this.filteredTrainings = this.filteredTrainings.filter(t => t.id !== id);
        this.updateFilterOptions();
        this.showSuccess('Training deleted successfully');
      }
    });
  }

  private showSuccess(message: string): void {
    Swal.fire({
      icon: 'success',
      title: 'Success',
      text: message,
      timer: 2000,
      showConfirmButton: false
    });
  }

  private formatDateForInput(dateString: string): string {
    const date = new Date(dateString);
    return date.toISOString().split('T')[0];
  }

  updateTotalPages(): void {
    this.totalPages = Math.ceil(this.filteredTrainings.length / this.itemsPerPage) || 1;
    
    // Adjust current page if it's now out of bounds
    if (this.currentPage > this.totalPages) {
      this.currentPage = this.totalPages > 0 ? this.totalPages : 1;
    }
  }

  get paginatedTrainings(): Training[] {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    return this.filteredTrainings.slice(startIndex, startIndex + this.itemsPerPage);
  }

  onPageChange(page: number): void {
    if (page >= 1 && page <= this.totalPages) {
      this.currentPage = page;
      // Optional: Scroll to top of the table
      this.scrollToTop();
    }
  }

  toggleFilterPanel(): void {
    this.showFilterPanel = !this.showFilterPanel;
  }

  isFilterActive(): boolean {
    return (
      this.searchQuery.trim() !== '' ||
      this.filterOptions.selectedStatus.size > 0 ||
      this.filterOptions.selectedLocations.size > 0 ||
      this.dateRange[0] !== null ||
      this.dateRange[1] !== null
    );
  }

  getActiveFilterCount(): number {
    let count = 0;
    if (this.searchQuery.trim() !== '') count++;
    count += this.filterOptions.selectedStatus.size;
    count += this.filterOptions.selectedLocations.size;
    if (this.dateRange[0] || this.dateRange[1]) count++;
    return count;
  }

  toggleFilterOption(type: 'status' | 'location', value: string): void {
    const selectedSet = type === 'status' 
      ? this.filterOptions.selectedStatus 
      : this.filterOptions.selectedLocations;
    
    if (selectedSet.has(value)) {
      selectedSet.delete(value);
    } else {
      selectedSet.add(value);
    }
    
    this.applyFilters();
  }

  private scrollToTop(): void {
    const tableElement = document.querySelector('.table-responsive');
    if (tableElement) {
      tableElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }
}
